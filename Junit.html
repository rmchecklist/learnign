Junit:
======
1. @Test - create a testcase method 
        @Test
        public void test(){
        }
2. @Test(expected=IllegalArgumentException.class) ==> If want to test any exception test case then use this to validate the expected exception
3. @Before/@After - This method will call for each test method, Before will before test and after will after the test method
        e.g. Before-->test1-->After
4. Junit4 --> Junit5
    Maven - Build/Project Management tool can build compile run and create package(jar/war/ear)
    Junit5 has 2 different jar file --> Junit junpiter engine
                                        Junit vintage engine
5. Migrating project from Junit4 to Junit5
    @Before/@After replaced by @BeforeEach/@AfterEach
    All these imports should refer from jupiter
    expected should be replaced by Assertions.assertThrows(NullpointerException.class, ()->{app.greet("")})
    (if Junit is not avaialble on eclipse then we need to install Junit platform runner and Junit jupiter api and add @RunWith(JunitPlatform.class) and then run as Junit 
6. Maven clean --> clean/delete the file under target dir
   Maven install -->  build the jar if all test cases are passed

Mockito:(Mocking framework)
===========================

Mocking involves 
        1. Stubbing  
        2. setting expections and 
        3. verifying 

MockitoAnnotations.initMocks(this); --> Scan the test class and look for @Mock classes and mock them by calling this line.

verify -->  This method can verify whether method is invoked or not


Junit5 with Mockito
===================

@ExtendWith(MockExtension.class) --> This wille extend all class related MockExtension

@Mock - Mock the class/interface
@InjectMocks --> Inject the mock and create an object 



Code coverage:
===============


Mockito verify:

1. verify(object, times()/atleast())
        e.g. verify(dao, times(2)).delete(123);
2. Matcher --> e.g. anyInt
3. doNothing().when(b).voidMethod()
3. mutiple return using doNothing().doThrow(RuntimeExceptio.class).when(b).voidMethod()
        --> Return nothing from 1st execution and throw exception from 2nd execution

F I R S T
=========

F -Fast
I - Independent
R - Repeatable
S - Self-validating
T -Timely


Test Doubles:
=============

Dummy
Stubs
Mocks
Fake
Spies

Spies: ==> Partially mock the object. Going to call the real object than mocked 
        e.g.
                myList.add("M");
		myList.add("R");
		Mockito.doReturn(3).when(myList).size();
		assertSame(3, myList.size());

Though actual size of the list is 2, we can mock them return 3

Mock vs Spy

1. Through mock method, we can call the real method using when(myList.size()).thenCallRealMethod();
2. Spy --> we need have real value to mock them, Hence it is called partial mocking


Maven:
=====

pom.xml ==> Project object model


Instead of using MockitoAnnotations.initMocks(this);, we can use @RunWith(MockitoJunitRunner.class) on the class


Parameterized Junit:
====================

1. Identifying the input data and results e.g. input ==> num1, num2 output==> result
2. Create a fields in the test class e.g. num1, num2, result
3. Create a constructor e.g. public calculatortest(int num1, int num2, int result){}
4. Create a static method
                        @Parameters
                        public static Collection<Integer[]> data(){
	                	return Arrays.asList(new Integer[][] {{-1,2,1}, {1,2,3}, {6,7,12}});
                        
                        }
4. @RunWith(Parameterized.class) --> on the class


Powermock Introduction:(This can be used to invoke a static method)
=======================

Mockito limitation:
        static, Final, Constructor, Private, Enums ==> This can be overcome by powermockito
                                
                                
How to use powermock:
                                @RunWith(PowerMockRunner.class)
                                @PrepareForTest(IdGenerator.class)
                                
                                
                                
                                

